#' Plot leaflet choropleth
#' 
#' @description Plot interactive choropleth using leaflet with a simplified theme designed for 
#' improved appearance in the absence of background tiles. The theme requires pitoolbox to be 
#' installed locally. **NOTE**: if you would like to use the embedded `crosstalk` functionality of
#' [render_map()], 
#' [you *must* install a patched version of leaflet](https://github.com/rstudio/leaflet/pull/499) 
#' from github: `devtools::install_github("dmurdoch/leaflet@crosstalk4")`. If you do not want to 
#' install this version, the `crosstalk` behavior will silently fail but your code will otherwise 
#' run just fine.
#' 
#' @param df `dataframe / tibble / datatable` Dataset of values for the choropleth.
#' @param x `list` Named list where keys are the columns of `df` to plot and the values are the 
#'   names to be used as the layer and legend titles.
#' @param map `sf` A simple features dataset containing GIS data to join with df.  
#' @param date `date` Date to be plotted. If NULL, the most recent available date is used. Default 
#'   is NULL.
#' @param id_label `chr` Column name in `df` to use as the shape name in the tooltip.
#' @param info_labels `list` Named list corresponding to the `df` columns (keys) and desired label 
#'   text (values) to appear in the tooltip. By default, the list `x` will be used.
#' @param palette `list` List of palettes to be used for the respective variables in x. The list 
#'   can be named to match the keys of x, if not the palettes will be taken in order. Palettes  
#'   should be a general palette name (eg: 'Blues'). In the case of factor variables, a vector 
#'   of specific colors can be given instead. **Note**: for factor variables, the variable itself
#'   must already be ordered in `df`, otherwise the factors will be ordered by appearance. If no
#'   palette is provided, 'Blues' will be used for every layer.
#' @param collapse_controls `bool` If True and if more than one layer is present (ie, if 
#'   `length(x) > 1`), then the layer control in the top right corner will be collapsed. Default is
#'   TRUE.
#' @param legend `bool` If True, the legend will be shown in the bottom right corner. Default is 
#'   TRUE.
#' @param legend_position `chr` The desired position of the legend. Default is 'bottomright'.
#' @param crosstalk `bool` If TRUE, the map data created and used will be converted into a 
#'   [crosstalk](https://rstudio.github.io/crosstalk/) `SharedData` object. **Note:** enabling 
#'   crosstalk is mutually exclusive to other aspects of `render_map`, in particular it cannot be
#'   used on maps with multiple layers. Default is 
#'   FALSE.
#' @param crosstalk_key `chr` If crosstalk is TRUE, `crosstalk_key` allows you to optionally 
#'   specify which column in `df` to use as the key for the SharedData. Default is NULL, meaning
#'   no key will be specified.
#' @param crosstalk_group `chr` If `crosstalk` is TRUE, `crosstalk_group` allows you to specify the
#'   group id name provided to `SharedData`. Default is NULL, meaning a random group name will be 
#'   generated by crosstalk.
#' @param ... Additional arguments to be passed to [make_leaflet_labels()]
#' 
#' @return `leaflet widget`
#' 
#' @examples
#' \dontrun{
#' library(dplyr)
#' 
#' df_dep %>%
#'   group_by(dep) %>%
#'   mutate(p_evo = evolution(p)) %>%
#'   ungroup() %>%
#'   render_map(x = c(p = 'Cases',
#'                    pop = 'Population'),
#'              id_label = 'dep',
#'              evolution = c('p'))
#'} 
#' 
#' @importFrom dplyr %>% filter left_join
#' @importFrom methods as
#' @importFrom leaflet leaflet colorBin addPolygons labelOptions highlightOptions addLegend
#'   addLayersControl layersControlOptions colorFactor
#' @importFrom htmlwidgets onRender
#' @importFrom htmltools htmlDependency
#' @importFrom viridis viridis
#' @importFrom crosstalk SharedData
#' @importFrom rlang .data
#' @importFrom tinker %notin% french_format up_down_format
#' @export
render_map <- function(df, x, map, date = NULL,  
                         id_label = 1, info_labels = x,
                         palette = NULL, collapse_controls = FALSE,
                         legend = TRUE, legend_position = 'bottomright',
                         crosstalk = FALSE, crosstalk_key = NULL, crosstalk_group = NULL,
                         ...) {
  
  if (is.null(palette)) {
    palette <- rep('Blues', length(x))
  }

  if (is.null(names(palette))) {
    names(palette) <- names(x)
  }

  if ('date' %in% names(df)) {
    plot_date <- ifelse(is.null(date), max(df$date), date)

    df <- df %>% filter(.data$date == plot_date)   
  }

  # throw error if map isn't sf format
  if ('sf' %notin% class(map)) {
    stop('custom_map must be of type sf (simple features object)')
  }


  data <- map %>%
            left_join(df,
                      sort = FALSE) %>%
            as('Spatial')

  labels <- make_leaflet_labels(data = data,
                                id_label = id_label,
                                info_labels = info_labels,
                                ...)

  # initialize shareddata object for crosstalk
  if (crosstalk) {
    if (is.null(crosstalk_key)) {
      sd_data <- data %>%
                   SharedData$new(group = crosstalk_group)
    } else {
      sd_data <- data %>%
                   SharedData$new(key = ~.data[[crosstalk_key]], 
                                  group = crosstalk_group)
    }
  } else {
    sd_data <- data
  }


  map <- leaflet(sd_data)

  # build layers
  for (var in names(x)) {
    # define layer palette 
    if (is.numeric(df[[var]])) {
      pal <- colorBin(palette[[var]],
                      domain = data[[var]])
    } else {
      pal <- colorFactor(palette[[var]],
                         ordered = FALSE,
                         domain = data[[var]])
    }

    map <- map %>%
             addPolygons(group = x[[var]],
                         fillColor = ~pal(data[[var]]),
                         fillOpacity = 1,
                         color = 'black',
                         weight = 1,
                         label = labels,
                         labelOptions = labelOptions(textsize = '15px'),
                         highlightOptions = highlightOptions(weight = 5,
                                                             color = 'black')) %>%
             addLegend(group = x[[var]],
                       opacity = 1,
                       position = 'bottomright',
                       title = x[[var]],
                       pal = pal,
                       values = ~data[[var]])
  }

  # enable legend to change with layer
  if (length(x) > 1) {
    map <- map %>%
      addLayersControl(baseGroups = unname(x),
                       options = layersControlOptions(collapsed = collapse_controls)) %>%
      htmlwidgets::onRender("
        function(el, x) {
          var updateLegend = function () {
              var selectedGroup = document.querySelectorAll('input:checked')[0].nextSibling.innerText.substr(1);
 
               document.querySelectorAll('.legend').forEach(a => a.hidden=true);
               document.querySelectorAll('.legend').forEach(l => {
                 if (l.children[0].children[0].innerText == selectedGroup) l.hidden=false;
               });
           };
           updateLegend();
           this.on('baselayerchange', e => updateLegend());
      }")
  }

  return(map)
}


#' Make leaflet tooltip labels
#' 
#' @description Build the html tooltip text.
#' 
#' @param data `spatial polygon dataframe` Merged map data.
#' @param id_label `chr` Column name in `df` to use as the shape name in the tooltip.
#' @param info_labels `list` Named list corresponding to the `df` columns (keys) and desired label 
#'   text (values) to appear in the tooltip. By default, the list `x` will be used.
#' @param decimals `int` Number of decimal places to be shown. Passed to [tinker::french_format()].
#'   Default is 0.
#' @param percent `chr vector` Vector listing the names of variables in `info_labels` to be 
#'   displayed as percents. Passed to [french_format()]. Note that [french_format()] assumes the 
#'   values are *proportions* not *percents* (ie, to get 43%, you must input 0.43 not 43). Default
#'   is an empty list.
#' @param evolution `chr vector` Vector listing the names of variables in `info_labels` to have 
#'   their evolution included in the tooltip. **Warning**, [make_leaflet_labels()] assumes that 
#'   these evolutions are already in `data` with column names conforming to the format {name}_evo. 
#'   Default is an empty list.
#' @param flip_colors `chr vector` Vector listing the names of variables in `info_labels` where 
#'   the default evolution colors should be inverted. Passed to [tinker::up_down_format()]. Default
#'   is an empty list.
#' 
#' @return `list`
#' 
#' @export 
make_leaflet_labels <- function(data, id_label = 1, info_labels,
                                decimals = 0, percent = c(),
                                evolution = c(), flip_colors = c()) {

  labels <- paste0('<i style="font-size:1.1em">', data[[id_label]], '</i>')

  for (i in names(info_labels)) {
    labels <- paste0(labels,
                     '<br>',
                     info_labels[[i]],
                     ': <b>',
                     lapply(data[[i]], 
                            function(x) french_format(x,
                                                      decimals = decimals,
                                                      percent = i %in% percent)),
                     '</b> ')

    if (i %in% evolution) {
      labels <- paste0(labels,
                       lapply(data[[paste0(i, '_evo')]],
                              function(x) up_down_format(x,
                                                         flip_colors = i %in% flip_colors)))
    }
  }

  labels <- labels %>%
              lapply(htmltools::HTML)

  return(labels)
}

